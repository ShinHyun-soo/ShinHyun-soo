세그멘테이션 이즈 페이징
가상메모리개념 

가상적인 메모리

일반메모리는기억장치

주기억장치를 가리킴

보조기억장치는 주기억장치를 보조하는 역할

전원이 차단되면 없어지기 때문에

임시 저장소 같은 역할 수행

빠른것이 주된 요소가아님

보조기억장치의 일부를 주기억장치의 확장된 영역처럼 써보겠다.

작업장처럼 쓰는 것은 아님

일부를 보조기억장치의 일부로 잠깐 빼 놓는 것임.

보조기억장치의 내용을 cpu 가 직접 접근해서 처리할 수 없음.


보조기억장치는 하나의 블럭 단위로 입출력을 하는 것임.

왜블럭단위로해요

메모리처럼 한바이트씩하면 좋찮아

느리고, 디스크타 cd롬같은 경우 보면 기계적인 움직임이 필요함.

ssd 는 전기로접근하니까 메모리처럼 접근 가능

옛날에는 한바이트를 얻기 위해서 기계적으로 접근하기에는 비용이 너무 컸음.

블럭디바이스이다.

cpu 입장에서는 한 블럭의 데이터를 가져올수있다고하더라도

cpu는 보조기억장치와 직접 상호작용하지 않는다.

가상 메모리 개념은

현재 실행되고 있는 프로세세으ㅔ 대한 내용중 일부를 보조기억장치로 빼놓는 것

페이징, 세그멘테이션, 비연속 메모리 할당 기법

이 부분을 굳이 메모리에 두지 말고 창고 어딘가에 빼놔도 되지 않겠냐

모든 부분들이 항상 ㅏㄷ실행되는것은 아니기 때문에

참조의 지역성측면에서 보면 어떤 영역이 수행되면 주변이 접근됨

다른것은 당장은필요없음.

그자리에 다른 프로세스를 할당하게 되면

소위, 주기억장치에서 특정 프로세스를 보조기억으로 빼놓고 그자리에 다른 프로세스를 집어넣어주면

얻을수 있는 이점은, 다중 프로그래밍 정도를 높일 수 있음.
(동시에 실행될 수 있는 프로세스 수를 늘릴 수 있음.)

현재 메모리에 100개의 프레임

100/10 은 10개 프로세스

비연속적이든 연속적이든

하나의 프로세스를 수행하기 위한 모든 페이지들이

메모리에는 있엇어야됨.

10개 있을때 100개의 프레임이 꽉차게됨.

당장 실행하는데, 5개의

나머지 5개는 당장 필요하지 않다.

잠깐 빼놓자 창고에다가

일단 빼놓는다.

10개의 프로세스가 5개의 페이지 프레임만 쓰니까

나머지 50개가 빔

동시에 20개의 프로세스가 생김

그 개념이 가상 메모리

보조기억장치가 유한하더라도 

아주 큰 메인 메모리를 갖고 있는 시스템처럼 보여질 수 있다.

가상메모리를 관리하는 설정

내가 사용하고 있는 프로세스의 총 합이

현재 시스템의 물리적인 메모리 ㅇ ㅑㅇ보다 더 큰 용량을 사용 가능

가상 메모리의 설정을 수도으로 설정한다면, 

메모리 부족으로 더이상의 프로그램을 실행할 수 없습니다로 나올 수있음.

빈페이지 프로그램이 없으면 새로운 페이지 프로그램을 실행할 수 없음.


내가 프로그램을 수행하려고 했는데 부족하면

당장 안쓸 부분을 치워버리고 새로운프로세스를 수행할 수 있게 해준다.

초기에 나왔던 프로세스는 모든 내용을 통채로 뺐다가 통채로 가져오는

이번주자부터는 한 프로세스에 대한 모든 내용을 빼는 관점이 아니라

당장 사용되지 않는 페이지를 뺀다.

스와핑으로 사용하기는 함.

물리적인 메모리 보다 더 큰 프로그램을 실행시키거나

더 많을 수 있는

그런 상황으로 실행할 수 있다.

모든 메모리들이 메모리에 탑재되어야 있는건 아님.

당장 필요없는 것은 빼놨다가 가져옴

당장 필요없는것을 가져옴

다중 프로그래밍 정도를 높일 수 있다.

배치 시스템

cpu 이용도를 높이자.

응답률 같은 것들.

CPU 를 놀리지 말자.

내 시스템에서 처리하고자 하는 다양한 작업들을 동시에 수행

조금더 높일 수있는

이런 방법들의 한 과정

물리 적인 메모리

스왑 아웃 시켜놓고

cpu 는 물리적인 메모리를 접ㄱ

다시 가져오는 작업 스왑 인

속도가 많이 느려지기는 함

속도가 느려져도 실행 못하는 것보다는 나음.

오늘 날 우리가 수행하는 시스템에서는 가상메모리르 기본적으로 사용함.


가상 메모리 시스템

얻을 수 있는 이점.

다중 프로그램 페이징

각각의 프로세스들은 자기가 

더 많은 프로세스들을 수행 가능


메모리가 부족한 상황에 대해서 그리 신경쓰지 않아도도미

가성비를 높일 수 있는.

1byte 는 주기억장치가 비쌈

메모리 피라미드 구조에서 위쪽으로 접근할수록 ㅂ빠르지만 비쌈.

가상 메모리 시스템과 

여러가지 것들

새로운 개념들

하나씩설명

가상 메모리 시스템을

페이징, 세그멘테이션

요구 페이징(Demand Paging)

요구가 있을때 가져옴

모든 페이지를 

필요없는 것을 보조기억장치로 내쫓는것

하나의 프로그램을 실행하는 패턴

워드 다안씀 , 조그만한 기능만 사용함.

프로세스의 모든 내용들을 주기억장치로 가져오지 말고

당장 필요한 것만 갖고 오는 것은 어떤가

당장 요청이 필요 없는 것

나중에 필요한것만 가져옴..

스왑 영역에 보내놨다가

당장 필요한것만 갖다 놓고 나머지 부분이 필요한것이 

하나의 프로세스를 실행할 때

일단 10개륽 가져다 놓고

5개만 가져옴.

일부는 필요할때마다 1~2 가져옴.

하나의 프로세스를 왔다갔다 안해서

더 빠른 응답을 수행 되는 것처럼 보여질 수 있고

메모리가 더 많은 프로세스르르 수행할 수 있도록 됨.


페이지 테이블을 두되, 모든 페이지들을 미리 갖다 놓는 것이 아니라 요청이 있는 페이지들을 가져다돔

페이지 테이블을 기존에 사용하늑 것과 그대로 사용하면 ㅇ나됨.

모든 페이지가 메모리에 있다고 가정하는 기존의 페이지 테이블

가상 메모리에서 페이지 테이블은 모든 내용이 있는 것이 아님. (ssd 에 보냇을수도 잇음0

각 페이지가 저장되어잇는 현재 그 페이지가 물리 메모리에 있느냐 여부를 따지는 valid / presence bit

현재 물리적인 메모리를 할당 받고 있구나

valid bit 0 이면 해당하는 영역이 없구나.


modified bit (dirty bit)

해당하고 잇는 페이지가 수정 여부를 담고 있는 비트임.

수정 여부를 저장해서 뭘 할수 있느냐

해당하는 페이지가 수정되지 않았으면 

디스크에 있는 내용들을 메모리에 탑재하는데 

비주얼 수튜디오를 필요하는 코드영역 정적, 힙, 스택

당장 필요없는 페이지

기본적인 메인함수의 시작 부분

잘 안쓰는 디버거 기능

당장 디버거를 구동하기 전까지는 필요없음.

디버거 코드 페이지는 가져오지 않아도 되더라.

해당하는 디버깅 과정에서 디버깅 페이지 코드를 가져옴.

거꾸로 컴파일읋 한다거나, 에디팅 기능은 필요 없음.

소스코드를 편집하는 기능을 담고 있는 페이지를

freaking space 로 보내놓고

프로그램 코드 컴파일러가 컴파일 햇을때 

실행파일로 읽어들이면 언제 읽어들여도 ㄷ똑같음.

입력한 소스코드에 

지역 변수, 전역 변수

동적 할당 시시각각 달라짐.

그런데 코드ㅡ 영역은 읽어온 이후에 실행만 하면 되는 영역

스왑 아웃

그냥 버려버려도 된다.

32 비트 시스템에서 다 사용

제일 위이ㅔ 코드 영역 

중간에 빈 공간  

메모리에 확보 했다가 

해제.

굳이 스왑 아웃 영역에 저장안해도ㅗ딤.

이런걸 결정하는게 modified bit 

수정 된 적이 있다 한다면 뭐가 수정됬는지르 ㄹ꼭 기록해야함.

나중에 이 페이지 프레임을 디스크로 스왑 아웃 하고자 한다면 그대로 복사해서 저장해야함.

가져온 이후에 수정된적이 없다. 나중에 디스크로 가져올때는 굳이 저장안해도 됨.

그냥 없애버려도됨.

디스크에 쓰느라고 시간 쓰지 말고

그냥 디스크에 있는 걸 읽어들이면 되니까 

효율적인 스와핑이 가능.


페이지를 참조하려고 햇는데 없어.

메모리에 탑재되어잇지 않다고 판단이 되이지ㅡㄴ ㄴ상황

페이지 부재(Page Fault)

일반적인 페이징 시스템이서는 페이지가 없는 상황이 존재하지 않음.

모든 페이지가 메모리에 없을 수 도 있기 때무넹

메모리에 없다라는 신호를 page fault 페이지 부재

페이지 부재가 발생되게 디면 

특히 이 과정이 하나의 명령어 사이클 내에서 발생이 된다고 하면

크게 보면 인스트럭션

명령어를 가져오는 인스트럭션 패치

가져온 명령어를 실행

기본적으로 보면 명령어 가져오는 단계, 실행하는 단계

instruction list 명령어를 실행하는 단계

그 명령어를 실행하기 위해서 필요한 동작

alu 로 계산을 해라

그 가져온 명령들이 실행이 다끝나는 경우가 한 명령어 처리가 끝나는 것

그다음 명령어 가져와서 실행하고

그 과정들을 사실상 굉장히 복잡

그 과정이 복잡하며 ㄴ뭐가 복잡해질까요

cpu 에 제어 장치가 무척 복잡해짐

가장 복잡한 장치는 제어장치

제어장치를 cpu 마다 적재적소에 할수잇도록 설계

하드웨어로 일일이 설계하면

어려움

micro programing 으로 

그럼에도 어려움

제어장치를 복잡하게 하는 것은 지양.

interuppt 는 비동기적인 신호

하나의 명령어 사이클이 다끝난 다음에 확인

명령어 인출하고 인출한 명령어 실행하고.

왜 인터럽트가 발생햇을대 중간에 끼어들어서 처리하지 않느냐

어디까지 수행하고 따로 기억해놧다가 재개해주는 처리를 해야하는데

하나의 사이클

명령어 처리한다고 하면 cpu register 

다른 명령어를 백업하고 다시 복원하고

중간에 가로채지 않고

하나의 명령이 끝난 다음에 처림

page fault 발생한다면 가져온 명령어를 실행

데이터 가져오는 명령어

그 페이지가 없어 Page fault 발생

따로 기억해두려고

재기하려고 기억하는 것이 아니라 처음부터 다시 수행하게 됨.

Page fault 발생시 다시 실행으로 

충분한 ㅎ=페이지가 확보되지 못하다

다시 없어졋는데

다시 가져오고

page fault 만 발생

하나의 프로세스

하나의 명령이 수행되기 우해서는

충분한 페이지가 보장

배열이 있다고 했을때, 

int arr[1000000]

이 배열에 접근하기 위해서 0부터 순차적으로 할때와

왔다갓다 할때 cpu 입장에서 보면 똑같음

1차원 배열 순차적

2차원 배열
int arr[1000][10000];

접근 할때, 
for (int i = 0; i < 1000; i++)
	for (int j = 0; j < 1000; j++)
		arr[i][j] = 0;


for (int j = 0; j < 1000; j++)
	for (int i = 0; i < 1000; i++)
		arr[i][j] = 0;


둘다 처리 되는가?

둘다 처리 되어 질 수 있음.

만개짜리 일차원 배열이 천개 있다.

첫번째 그룹의 갯수

그룹당 요소의 갯수

만개의 일차원 배열을 천개 묶어논 상황

i 1000 개 천개 의 그룹 번호

0번그룹 1번그룹

j 그룹당 요소의 번호를 식별

1번 그룹도 만개

3번그룹도 만개

...


1부터 10000개

j loop j 가 0인 동안에, j 는 두번째 첨자니까

j 값이 1 증가되니까

1번 요소

loop를 돌면 만번씩 천번 돌고

cpu 가 접근하는 측면만 본다면

우리가 사용하는 가상메모리의 개념으로 접근해본다면

어떤 방법을 왜

1번을 2번보다 더 효율적일 가능성이 있다.

1. 0 번 그룹에 대해서 만번 접근 ㅇ하나의 페이지(인접페이지에 들어갈 요소가 큼)

2. 1000 개의 그룹에서 0번 페이지는 하나의 페이지에 안들어갈 가능성이 큼(인접 페이지에 안들어갈 가능성이 큼0

서로 다른 페이지를 접근하는 코드

이왕 접근ㄴ했던거

매번 다른 페이지를 접근하는 것보다 훨씬 더 나음.

작은 크기의 배열일때는 상관 없음..(하나의 페이지에 있을 가능성이 크니까)

시뮬레이션 하듯이

요구 페이징 특징

fork() 시스템 호출

fork 시스템 복사해서 자식 개체를 만들고 나서

부모가 하는 일을 이어서 하는 경우도 잇지만

새로운 개념으로 대체

포크 시스템으로 부모랑 똑같은 프로세스로 만들기 위해서 별도의 공간의로 할당

다시 엎어치기

효율성이 떨어짐.

초기에는 공유만 하다가 바뀌는 부분이 있다.

요구페이지 관련 이슈

페이지 부재가 많이 발생해서 시스템의 성능이 떨어지는 상황(스레싱)

페이지 교체는 보조 기억 장치로 접근해야함.

적게 일어나면 좋음.

찾아 오거나 쫓아 오거나

어느 순간에 실제 프로세스 

작업으 ㄹ실행하는 시간보다 교체하는데 수행을 한다면

일이 진행되기보다는 디스크만 과도하게 

제대로 수행이 안되는 것이 스레싱

다중프로그래밍 정도가 임계정을 

cpu 이용 제대로 일을 처리하지 못하면서

많은 시간들을 소비

스레싱들이 일어나지 않을 수 잇또록 처리함

참조의 지역성

현재 내가 최근에 특정 부분들을 접근햇던 가능성들을 높일 수 있는 특징을 가지고 있다.

하나의 프로세스가 실행할 때 얼마의 프로세스가 필요하냐

작업을 수행하기 우해서 필요한 작업들으 묶음.

작업 집합 내의 

주로 작업들을 수행해 나가기 때문에

page fault 증가하닥

페이지 fault 율이 떨어지고

한동안 유지하다가 다시 증가하는

대략적으로 page fault 율이 떨어졌다가 다시 유지되는 한 사이큳를 작업 집합

최소한 그 프로세스에게 할당 될 수 잇어야 한다.

페이지 fault 율이 증가하게 됨.

스레싱 


참조의 지엳성들은 최소 페이지가 

갖는 의막 뭔지

가상 메모리가 무엇이고 어떻게 관리하자는 것이닞

실제 구현한 한 방법으로서 디멘드 페이징

뭐가 다른지 식별을 해야함

디멘드 페이징과 그냥 페이징을

헷갈림

완전히 다름

그냥 페이징 : 가상 메모리 개념이 없음.

디멘드 페이징 : 가상 메모리 개념이 있음.

남은 부분

내쫓는가 누구를

여러가지 알고리즘.

14주차 강의에서 

학기 말까지 미리 올려둠.

학습할 수 있느 시간을 여유롭게 

14, 15 미리 기말 준비




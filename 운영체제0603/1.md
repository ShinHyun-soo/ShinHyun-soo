## 가상메모리

지난 이야기...

가상메모리 대략적인 이야기

필요한 페이지를 요청 하는 세그먼트

하나의 프로세스 모든 공간 세그먼트들을 메모리

이번 주차 

세부적인 가상메모리 시스템에서 논의해야할 사항 <프레임 할당>

어떻게 할것이냐

전통적인 메모리 관리 ㅅ시ㅡ템

하나의 프로세스에 모든 프레임 

가상메모리에서는 모든 거 할당할거아니니까

얼마만큼의 프레임ㅇ르 할당할것이낙

내가 미처 할당하지 않은 어떤페이지
추가적으로 할당하는 페이지

더이상 사용가능한 메모리가 없다고하면 ??

빈 프레임이 있으면 해당하는 ㅔ임 할당

공교롭게도

빈공가닝 없다면

비워내야함

어떤 프로세스

프레임 할당 알고리즘과 페이지 교체 알고리즘

하나의 프레임에 
두가지 지표

하나의 프로세스가 실행되기 위해서는

최소 프레임수가 확보 되어야함.

최소 프레임수가 확보되지 않으면

하나아ㅢ 명령이 수행됙 위해서

페이지 폴트 발생

처음부터 재실행

오버헤드

시간을 보내고 다시 

또 없으면

하나의 명령이 수행되기 전에

확보 되어ㅣㅈ는 것이 필요함.

얼마나 많이 필요하냐

프로그램 내부에서 대략적으로
워킹셋 작업집합

ㅍ페이지 폴트 횟수가 줄엇다가 

작업 집합 크기

일반적으로 큰 문제 없이

여유롭게 할당해주면

때때로 

남음 하나의 프로세스에 대해서 지나치게 많은 다중 프로그래밍 정도가 떨어짐.

각각의 프로세스에 대해 페이지 프로할당 방법은

3가지 모든 프로세스에 대해 똑같은 갯수만 할당할 것이닞
프로세스 크기
프로세스 중요도에 따라서 할당할 것이닞

똑같이 할당은 가장 간단하지만 효율적이지 않음;

비례할당, 우선순위 할당

프로세스 크기가 크다고 하면

더 많은 페이지를 할당

우선순위 할당은 많이 할당해주면 페이지 폴트가 덜 ㅎ발생, 프로그램 빨리 실행

페이지 교체

프레임 할당해주는 것은

더크게 문제될것은 없다.

페이지 교체 

물리적인 메모리 

스왑 영역으로 내보낼것이낙

완전히 없애긴 본다는 

당장 스왑영역은 cpu 가 사용읆 못함

당장 사용되지 않을 내용이 메모리를 할당한다면

당장 사용할 다른 당장 사용되지 않을 페이지들의 프로세스를 스왑 영역으로
너나가잇어

페이지 교체

페이지 폴트(페이지가 현재 메모리에 없다)

페이지를 찾아서 메모리를 데려오는 일

페이지 교체가 필요한 일이 일어난다.

모디파이빗

수정 여부들을 두어 현재 수정되이ㅓ 잇지 않은 페이지를 다음번에 다시 디스크로

어떤 데이터를 유지

스왑 아웃 따로 저장을 해두고 

페이지 메모리 프레임에서 스왑영역으로 아예 ㅇ벗에버리는것을 페이지 교체

교체 되어질 영역들을 페이지 교체 알고리즘

어떤 사황에서도 치적이 있다

펭페이지 교체 역시 누구를 희생프레임에 될지

딱 정할 수 있는 부분은 아님.

페이지 교체를 하게되엇을때 

페이지 교체되어지길 희망

다양한 아록리즘

페이지 교체를 한 큰 고나저

지역적인 교체와 전역적인 교체

지역적인 교체, 내것중에서
전역적인 교체 우리것에서

지역적인 교체다 하면 특정 a vmfhtptmdp rycpgownsms

전역적인 교체다 a 에서 발생해도 그냥 다교체

지역적인 교체를 한다 하면 각 프로세스 마다 할당 바뀌지 않는다
널널한 프로세스는 계속 널널

모자란 프로세스느 게속 일어남.

시스템 전체 차원에서 보면 교체를 많이 하는 프로세스는 계속 교체하고

거의 안하는 프로세스느 안함.

전ㅇ역 교체를 한다.

다른 프로ㅔㅅ스 프레임도 교체받아서 가져올수잇다.

상대적으로 어느 프로세스와 같이 사용되느냐,
전체적으로 페이지 프레임수가 달라질수잇는 여지가 잇다.

## 페이지 교체 알고리즘 

어떤 이미 할당받은 프레임ㅇ르 교체하는 

정답은 없다.
하나의 참조열을 기반ㅇ르ㅗ 해서

로깅

특저 ㅇ참조열에따라 페이지 교체를 수행햇을때

페이지 폴트가 덜 일어나게

성능 비기ㅛ

대략적인 추세

프레임의 갯수가 늘어날수록
많으면 맣ㅇ르수록

페이지 폴트는 떨어지는 추세

페이지 교체 알고리즘의 종류는 여러가지가 잇다

cpu 스케쥴링 알고리즘때도 

누구에게 할당할것인가

메모리 프레임을 누구를 스왑 영역으로 빼낼것인가, 교채 대상으로 삼을 것이낙


FIFO 페이지 교체 알고리즘은
먼저 들어온 것을 먼저 내보내는

그다지 성능이 좋은 방법은 아님.

각각의 메모리 프레임 벼로

오래된 애를 비워내는

새로운 교체대상이 나오면 내쫓는

페이지 교체가 일어난 횟수와 페이지 폴트가 일어난 횟수가 다름

다른 개념이다 페이지 교체와 페이지 폴트는

페이지 부재

페이지 교체

페이지가 없기 때문에 

해당하는 페이지를 가져오는 일을

가져올 곳이 없으면 교체

7번 페이지가 필욯다 페이지 폴트 발생

가져오는데 페이지 교체는 안이일어남

0 페이지 필요 없으니 페이지 폴트

1번 페이지  

2번 페이지폴트, 가져올 곳이 없으니까 누군가를 내쫓는 일

7을 내쫒층ㅁ

그니까 페이지 폴트가 일어나서 가져올곳이 없으면 페이지 교체를 함.


페이지 교체가 몇번 ㅇ리어낫ㄴ

헷갈리지 말것

페이지 교체율

전체 메모리를 접근하는 횟수

페이지 폴트

교체율은 교체가 몇번 됐는지

fifo 는 페이지 프레임을 늘리면

프레임이 줄어드는 것이 일반적인 추세

특별한 상황에서는 페이지 프레임 폴트율이 늘어나게됨는 일이 일어날수도잇다.

벌레디의 모순

안좋은 교차 알고리즘이다 (Fifo)

가장 최적의 알고리즘에는 무엇이 있을까

## Optimial algorithm

앞으로 가장 오랫동안 사용되지 않을 page frame 을 내쫓자

바랍직하다

한번도 사용되지 않으 ㄴ프레임을 내좇는게 

한참 뒤에 사용되어질 프레임을 내쫓자

페이지 폴트율을 낮게

Optimal algorithm

이보다 더 좋ㅇ르 수는 없다.

현실적이지 는 않은

앞으로 가장 오랫동안 사용되지 않을 페이지를 어케암. 

어떤 페이지를 접근하면서 미리 가정을 헷기 대문에

실제 하나의 프로세스가 수해되어진다

최적이기는 하나 현실적이지는 않음.

가이드 라인 알고리즘에 불가함.

701 탑재되고나서 2번 페이지가 필요하다할때 701 페이지, 2 w집어넣ㅇ르 페이지

7이 들어온지 가장 오랫도안 사용되지 않을 페이지


0번 1번은 나중에 쓰잔항 7은 더나중에쓰네 그럼 7을 내쫓자

그래야 page fault 가 최저로발생

이 순서 

어떤 순서로 어떻게 접근하찌

이모르기때문에 이상적인 알고리즘

## LRU 알고리즘을 소개

일반적으로 좋은 성능을 나타내는 ㅇ라고리즘

기본적인 알고리즘 LRU

Leaset Recentlry Used 미래를 내다볼수는 엇ㅂ으니까 과거를 내다보자
LRU 알고리즘은 이력을 보면서 오랫동안 사용되지 않앗다 지역성의 원리 

또 참조되어질 일이 적을 수 있다.

도서관에서 책을 빌려온다

대출 서적에 제한이 있다.

5번까지 대출

그과정중에 내가 가져온 대출받아온 책들을 볼때마다 이력을 남겨 놓아

볼때마다 남겨놓은 태그

제일 오래전에 태그가 남긴 페이지 를 반납.

fifio 처럼 밸러디 모순도 알이얼남.

비교적 ㅈ호은 성능을 나타냄

LRU 알고리즘은 가장 큰 단점이 있어요

많은 정보들을 저장하고 관리해야한다.

각가의 페이지에 접근할때마다 언제 마지막으로 접근햇는ㄷ지 태그를 다달아야함.

책한번 펴볼때마다 기록을 해야함.

다기록을 해야함

도서관에서빌려온책정도는 

페이지 프레임 메모리를 접근하기 위해서 메모리 어떤 ㅍ특정 페이지르 ㄹ접근할때마다 시각정보들을 다ㅣ 고록을 해줘야한다면

cpu 무척 자주 있잔항요

언제 접근햇구나

교체한닿 햇을때

모든 가장 오래된걸 찾는다는 저장량도 많고 비교 연산량도 많다.  

성능을 기대 그래도 여전히 물리적으로 부담이 많이 되어지느 ㄴ방법이기도 하더라

메모리르 두번 세번 접근하게 되어지는 문제들이

LRU 알고리즘을 구현하기 위한 변종 방법들이

LRU 알고리즘을 어떻게 처리할거냐 
## 1 . Age Counter 사용

해당하는 

## 2. Stack

내가 접근하는 페이지를 최상단

스택의 마지막에 잇는 것이 오래된 페이지다.

701 할당

2번이라는 값이 접근할때

오래된 

7번 0 번 1번

들어오자마자 사용

7번을 교체

2번 201ㄱ

오래된놈을 교체

순수 LRU 보다는 근사화된 알고리즘

대략적인 정순서들을 추정할수잇는 ㅇ라고리즘이 lRU 근접 알고리즘


참조비트

정확한 시

해당하는 페이지들을 참조햇다 

참조유무를 

레퍼런스 피트 한두비트

적은양의 정보를 저장할수잇기는 하는데 순서를 호가인하긴 어렵다

8비트 16비트

일정한 시간 마다 

1로 셑하고 

서로 다른 참조 비트가 잇다

0000000이면 없구나

111 11 이면 매시각 참조햇구나

1100 0100 불규칙하게 참조햇구나

1100 0100 > 0111 0111 (교체대상)
숫자의 크기를 비교해서 더크면 상위 비트 셋 가능성

더 최근에 사용되어진것

해결해놀수잇다.

# 2차기회 알고리즘

한번 살려줄 기호를 주겟다

기본적으론느 fifo 먼저 정책을 취하되, 계속 자주 사용되도

오래됫다고 내보내는것이아니라

참조여부를 

어떤 포인터를 통해서 순환 큐

페이지 프포인터를 통해서 참조할 대상을 살펴보돼

각각의 페이짐 프레임보다는 추가적인 참조비트
다시 사용하면 1로 설정
0으로 설정된 페이지는 희생 프레임ㅇ르ㅗ 생성되면 즉각적으로 내보냄
최근에 참조됏던페이지면 오래됏지만 한번 살려줌.

1인지 확인

제거할 대상 순환 큐

참조해봣ㅇ르대 이미 참조해ㅏㄴ 흔적이 잇으면 0으로 바꾸고 다음 요소를 찾음.



0으로 되어잇으면 제거

더불어서, 확장된 이차배열알고리즘

참조 됏다 

보다는 해당하는 페이지 프레임에 변경 여부도 같이 저장함으로써

어떤 페이지 프레임을 교체한다 햇을때

사용되어지 페이지는

사용되이지지 않은 페이지보다 다시 사용될 가능성이 높기때문에

사용되어지지 않은 페

사용되지 않앗거나 변경되 여부가 잇다면 변경되지 않은 에이지는 변경되어진 교체 대생에 우선순위를 높여주자

둘다 사용되지 않았어

변경된 흔적이 없어

변경된 ㅎ느적이 잇어

변경된 흔적이 없는애를

변경된 흔적이 잇는애보다 먼저 교체하는 것이 바람직할 확류링 잇다.

왜냐면

교체한다라는 것은 페이지를)

현재 메모리를 스왑영역에 저장

근데 변경되어진 이력이 없는 애는 굳이 스왑영역에 저장안해도됨 그냥 버려도됨

어차피 디스크로 가져올것이니까

스왑영역에서 가져오나 디스크로가져오나 똑같음

스압아웃

변경되어지 ㄴ이력이 있는애는 

그냥 버리면 안됨

스오ㅓ방여역에 저장

나중에 스왑영역에서 가져와야됨

애는 
스왑하는데 시가닝 적게 걸림.



ㅓ사용되면서 

당연히 사용되어진 흔적이 없는게 

앞으로 사용될가능성이 없다.

둘다 사용되어지 ㄴ흔적이 잇다면

하나는 벼경, 변경x
변경x 교체할때는 그냥 버리면 되서 스압 아웃에 저장안해도됨.

그니까 변경 x선택

LRU 그저 참조 횟수를 저장하는 압업도 잇다.

## LFU (가정 적게 사용한 페이지)

가장 적게 ㅏㅁ조한 체이지는 필요없다

많이 접근한 페이지를 남겨둠으로써 도 사용될 여지를 높이자

적게 사용될 페이지를 교체

근데 문제가잇어요

들어온지 얼마 안돼서 적게 사용된 페이지는 쫓아낸다하면

성능에 좋은 영향을 못줌

## MFU 들어온지 오래되서

많이 참조된 페이지는 ㅈ충분히 사용되엇을것으로 추측 교체해버리자.

단점 : 많이 사용되엇다는 것이 충분히 사용되엇다와 일맥상통하지 않ㅇ르 숭 잇다.

성능측면에선 좋지 않다.




